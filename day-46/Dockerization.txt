Generate Docker Images - 3 approaches
1) Dockerfile
2) Buildpacks    mvn goal: spring-boot:build-image
3) Google Jib	

----------------------------------------------------------------------------------------------------
1) create a spring boot project
2) create a WelcomeRestController and have a get mapping for /welcome
3) in pom.xml - provide <finalName>sb-docker.jar</finalName>, <packaging>jar....
4) package the application
    cmd> mvn clean install

5) check 
  to run the application
cmd>java -jar sb-docker.jar 		OR 	using Maven ---> mvn spring-boot:run

6) create a file with the name of "Dockerfile" in project folder

# start with a base image containing Java runtime
FROM openjdk:17-jdk-slim   	FROM eclipse-temurin:21    openjdk:26-ea-trixie

# information around who maintains the image
MAINTAINER cognizant.com

# add the application's jar to the image
COPY target/sb-docker.jar sb-docker.jar

# execute the application
ENTRYPOINT ["java", "-jar", "sb-docker.jar"]   
#whenever someone is trying to generate a container from my docker image - please execute 
         java -jar sb-docker.jar command


in addition (not required)
EXPOSE 5000    ----> Informs Docker about the port that the container listens on at runtime  xx


7) create a docker image

cmd> docker build . -t sb-docker:1.0

- with this command we are telling to docker server there is a Dockerfile inside this folder (. - current folder) - please use the instructions and generate a docker image with the name specified
1.0 is the version (tag)

8) testing
cmd>docker images       docker image ls       docker image list


cmd> docker inspect image <image_id>   --> -- to know whether the docker image is created successfully based on the instructions in Dockerfile



to run the above image or to create a container

cmd>docker run -d -p 9090:8080 sb-docker:1.0

 -p port mapping
 9090:8080 --- what we are telling to the docker server is -  my "docker container" is going to start in the port 8080 (second)
 where as with the first port we are telling to the docker - please expose the  container outside of the docker network at the port 9090; anyone wants to communicate with this container from outside of the docker network , they have to use the first port number in port mapping


cmd> docker ps 
cmd> docker ps -a    ---> all containers included killed ones


- stop the container
cmd>docker stop <container_id 5chars..>

-- to restart the container
cmd>docker start <stopped_container_id>

---------------------------------------------------------------------------
Pushing and Pulling Docker Image to/from Docker Hub

cmd> docker tag sb-docker:1.0 150478/sb-docker:1.0

- Docker Hub is a Service provided by Docker for finding and sharing  your container images with your teams or with the general public	
https://hub.docker.com  & login

In Command Prompt:

cmd> docker login
username: 150478
password: 11Sxxxxx2


cmd> docker image ls

cmd>docker push <image_name_with_tag>

cmd>docker pull 150478/zettamine:1.0


-- to create a new tag

cmd>docker tag <image_name> <dockerhub_user_name>/<image_name>:1.0.1

cmd>docker tag 150478/sb-docker:1.0 150478/sb-docker:1.1

cmd>docker push 150478/sb-docker:1.1
11782316



==============================================================
Generate Docker Image of Accounts Microservice with Dockerfile
==============================================================
pom.xml --- <packaging>jar</packaging>
<finalName>accounts</finalName>

In application.properties, add following setting --
 spring.h2.console.settings.web-allow-others=true


cmd>mvn -version
cmd>mvn clean install	OR   mvn clean compile package -DskipTests

---- to run the microservice -----
cmd>mvn spring-boot:run

cmd>java -jar target/accounts.jar

==> Create a file with name "Dockerfile" in project folder

# start with a base image containing Java runtime
FROM openjdk:17-jdk-slim 	openjdk:26-ea-trixie  eclipse-temurin:21

# add the application's jar to the image
COPY target/accounts.jar accounts.jar

# execute the application - whenever someone is trying to generate a container from my docker image - please execute java -jar xxx.jar command

ENTRYPOINT ["java", "-jar", "accounts.jar"]




cmd>docker version
--- docker is installed correctly

cmd> docker build . -t 150478/accounts:v1

150478 - docker account user name - with this command we are telling to docker server there is a Dockerfile inside this folder - please use the instrucions and generate a docker image with the name specified

cmd> docker images

cmd> docker inspect image <image_id>
-- to know whether the docker image is created successfully based on the instructions in Dockerfile


--- Running Docker Image of accounts microservice with Dockerfile -----

cmd>docker run -d -p 8080:8080 150478/accounts:v1
 -p port mapping
 8080:8080 --- what we are telling to the docker server is -  my "docker container" is going to start in the port 8080 (second)
 where as with the first port we are telling to the docker - please expose the  container outside of the docker network at the port 8080; anyone wants to communicate with this container from outside of the docker network , they have to use the first port number in port mapping

cmd>docker run -d -p 8080:8080 150478/accounts:v1
	OR
cmd>docker run -d --name accounts-container -p 8080:8080 150478/accounts:v1


cmd> docker ps 
cmd> docker ps -a    ---> all containers included killed ones


- stop the container & start it
cmd> docker stop <container_id>
cmd>docker start <stopped_container_id>
---------------------------------------------------------------------------------


--- Challenges with Dockerfile approach to generate the Docker Image -----

1) we need to be an expert of docker to write the commands in Dockerfile - as a java developer (not DevOps engineer)- still we need to know the Dockerfile commands like FROM, MAINTAINER, COPY, ENTRYPOINT, WORKDIR etc - think of a situation where the Dockerfile is large - lot of learning curve involved for the developer - why should java developer should know about it?

2) we should know the best practices for creating a Docker file - like the size should be as small as possible, caching, compression, security - our docker image should be secure

3) we need to put lot of efforts


===========================================================
Generate Docker Image of Loans microservice with Buildpacks
===========================================================

What is buildpacks?
 https://buildpacks.io/

 using buildpacks we can transform our application source code into images that can run on any cloud; no need of writing low level instructions in Dockerfile; with a single maven command we can generate a docker image very easily

buildpacks is developed by Heroku - later Pivotal  joined with Hiroku

buildpacks will scan our source code , dependencies and accordingly it is going to generate the docker image 

https://paketo.io/
paketo buildpacks <--- implementation of  buildpacks


<packaging>jar</packaging>
<finalName>loans</finalName>

spring-boot-maven-plugin - inside pom.xml - we can create a docker image and this plugin internally uses paketo buildpacks to make production ready docker image

<plugins>
 <plugin>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-maven-plugin</artifactId>
   <configuration>
     <!-- provide docker image name -->
     <image>
	<name>${project.artifactId}:v1</name>    150478/loans:v1
     </image>
     <excludes>
 	  <exclude>



====>   cmd>mvn clean spring-boot:build-image

downloads paketobuildpacks for the first time

cmd>docker images 
--check the size of Dockerfile and buildpack images

cmd>docker run -d -p 8081:8090 150478/loans:v1

try with postman/ swagger


<image>
 <name>150478/${project.artifactId}:v1</name>
 <createdDate>${maven.build.timestamp}</createdDate>
</image>



===========================================================
Generate Docker Image of Cards microservice with Google Jib
===========================================================

github.com/GoogleContainerTools/Jib

Jib is an open-source tool to containerize your Java applications, includes new features and is production-ready

Jib is going to work only for Java applications, where as buildpacks will work for other languages also

Jib organizes your application into distinct layers; dependencies, resources, and classes; and utilizes Docker image layer caching to keep builds fast by only rebuilding changes. Jib's layer organization and small base image keeps overall image size small which improves performance and portability.

Quick Start > Maven  -- Setup

<packaging>jar</packaging>
copy <plugin>

<build>
 <plugins>
  <plugin>
        <groupId>com.google.cloud.tools</groupId>
        <artifactId>jib-maven-plugin</artifactId>
        <version>3.5.1</version>
        <configuration>
          <to>
            <image>${project.artifactId}:v1</image>
          </to>
        </configuration>
  </plugin>
 </plugins>
</build>


build your image - build to Docker daemon
cmd>mvn compile jib:dockerBuild	-DskipTests			
cmd>docker logout

Subsequent builds are much faster than the initial build (buildpacks)

CREATED date may be 43 years something (old date)- its not a bug -  they make a start date some where 1983
cmd>docker images   --- check the sizes

cmd>docker run -d -p 9000:9000 150478/cards:v1

Advantage of Google Jib - we can create docker image even if docker is not installed
Jib can also build your image directly to a Docker daemon. This uses the docker command line tool and requires that you have docker available on your PATH.



---- Compare Dockerfile , Buildpacks, Jib approaches ----------

https://buildpacks.io/features/			---> Comparison


----- Pushing Docker Images from our local to remote Docker hub Repository ------

cmd>docker image push docker.io/150478/accounts:v1 
cmd>docker image push docker.io/150478/loans:v1 
cmd>docker image push docker.io/150478/cards:v1 

public view to private view in docker hub - settings - visibility settings - - only
- personal plan can have only one repository as private 

cmd>docker pull 150478/accounts:v1




============= Working with Docker Compose =============

Docker Compose is a component in the Docker ecosystem

Docker compose is used to handle multiple containers

Docker Compose is a tool for defining and running multi-container Docker applications. 

When dealing with the execution of multiple containers utilizing the Docker CLI can be error-prone. Writing commands directly in a terminal window can introduce errors, make the code difficult to comprehend, and pose challenges when attempting to implement version control.

We have 3 microservice images - accounts, cards and loans - to run all these 3 -we need to convert the 3 docker images to containers using "docker run" command. To start the 3 containers we need to issue 3 docker run commands along with image name and port mappings - here comes the use of Docker Compose

https://docs.docker.com/compose/

Docker Compose is a tool for defining and running multi-container applications. 
It is the key to unlocking a streamlined and efficient development and deployment experience.


Compose works in all environments; production, staging, development, testing, as well as CI workflows. It also has commands for managing the whole lifecycle of your application:
    - Start, stop, and rebuild services
    - View the status of running services
    - Stream the log output of running services
    - Run a one-off command on a service

Docker Compose will gets installed along with Docker Desktop

-- to install Docker compose if not available
https://docs.docker.com/compose/install/standalone/


cmd>docker compose version

practical - create a file with name "docker-compose.yml" 

services:
  accounts:
    image: "accounts:v1"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - ctsbank
  loans:
    image: "loans:v1"
    container_name: loans-ms
    ports:
      - "8090:8090"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - ctsbank
  cards:
    image: "cards:v1"
    container_name: cards-ms
    ports:
      - "9000:9000"
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - ctsbank
networks:
  ctsbank:
    driver: "bridge"

-----
accounts, cards, loans   -service name
container_name:  -- if we are not providing then it will be given with a default name
ports - port mapping
 - multiple elements can be  provided like an array , so that we need to provide -

accounts-ms we want provide max 700mb
networks:  - ctsbank  --> 

in this case there is no dependency between these 3 microservices - they are all going to start in isolated network

what if I have a dependency between these microservice ; or in future , each microservice need to talk to each other - in that scenario it is not going to work by default.

To make sure that the inter-communication is working - we need to tag all these microservices into a same network

networks - root element
  ctsbank:
    driver: "bridge"    -- we are telling to docker to create a network with name "ctsbank" with driver - bridge - so that our 3 microservices can communicate each other






---- Running All Microservice container using Docker Compose Command ------------------
cmd>docker compose up 
  OR
cmd>docker compose up -d      --- detached mode

cmd>docker ps

try running APIs in postman

cmd>docker compose down

cmd>docker ps
cmd>docker ps -a

cmd> docker compose up -d

cmd>docker compose stop
cmd>docker ps -a

cmd>docker compose start



---- Docker extension- Logs Explorer ------------------

Logs Explorer Extension --> View all your container logs in one place so you can debug and troubleshoot faster

Docker Desktop Dashboard -- Add Extensions  - Logs Explorer  - Install
 - open
 - no logs information as there is no containers are up

cmd>docker compose up -d

check in Log Explorer Extension

============================================
1. Using MySQL Database inside Microservices
============================================

$ docker run -p 3307:3306 --name accountsdb -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=accountsdb -d mysql 

Download & Install SQLECTRON - used to connect to any Database

Add -- 
Name: LocalAccountsDB		Database Type: MySQL
Server Name: localhost		Port: 3307
User: root			Password: root		> Test

2. Update Microservices Code to replace H2 DB with MySQL DB
===> accounts - pom.xml --- remove H2 and add MySQL dependency
===> accounts/application.yml

spring:
  datasource:
    url: jdbc:mysql://localhost:3307/accountsdb
    driverClassName: com.mysql.cj.jdbc.Driver
    username: root
    password: root
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
  sql:
    init:
      mode: always

resources/schema.sql



In real production, MySQL DBAs will attach a storage or volume where the data can be stored by the MySQL containers. That's why in real prod MySQL containers, we never lost data even if we delete or replace the MySQL Container


3. Update docker compose file to create & use MySQL DB

services:
  accountsdb:
    image: mysql
    container_name: accountsdb
    ports:
      - "3007:3006"
    healthcheck:
      test: ["CMD","mysqladmin","ping", "-h", "localhost"]
      timeout: 10s
      retries: 10
      interval: 10s
    environment:
      MYSQL_ROOT_PASSWORD: "root"
      MYSQL_DATABASE: "accountsdb"
    networks:
      - ctsbank
  accounts:
    image: "accounts:v1"
    container_name: accounts-ms
    ports:
      - "8080:8080"
    environment:
      SPRING_APPLICATION_NAME: accounts
      SPRING_DATASOURCE_URL: jdbc:mysql://accountsdb:3306/accountsdb
    depends_on:
      accountsdb:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 700m
    networks:
      - ctsbank

networks:
  ctsbank:
    driver: "bridge"


5. $ docker compose up


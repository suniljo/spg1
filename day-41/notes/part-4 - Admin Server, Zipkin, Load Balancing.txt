============
Admin Server
============
 -> It is used to monitor and manage all the APIs/ microservices at one place
 Ex:
 1. health checks
 2. config props
 3. url mappings
 4. beans loaded
 5. changing log levels
 6. thread dumps
 7. heap dumps etc

 -> It provides beautiful user interface/ dashboard to access all APIs actuator endpoints at one place


In a microservices architecture, an "admin server" typically refers to a centralized application - responsible for managing and monitoring the various individual microservices. It's primary purpose is to provide a unified interface and capabilities for observing the health, status, and performance of the distributed system.


====================================
Steps to Develop Spring Admin Server
=====================================
1. Create a Spring Boot Application - admin-server
   Dependency: "admin-server" - codecentric's Spring Boot Admin (Server)
2. Bootstrap class - @EnableAdminServer
3. server.port=1111
4. Access application in browser - we can see Admin Server URL  - http://localhost:1111



=============
Zipkin Server
=============

-> Zipkin is a distributed tracing system. 
-> It helps gather timing data needed to troubleshoot latency problems in service architectures
-> It is used for distributed tracing of our requests

Ex:
 1. how much time taking to process one request
 2. which microservice taking more time to process
 3. how many services involved in the request processing
 
 -> It provides beautiful user interface to access APIs execution details

Zipkin is an open-source distributed tracing system used to troubleshoot latency issues in service architectures. It helps visualize and gather timing data for requests as they flow through microservices, providing insights into service topology, performance bottlenecks, and error paths. Zipkin collects data from applications, stores it, and then provides a UI to search, analyze, and visualize these traces

meta data contains 4 parts 
a) Service Name - microservice name
b) Trace ID - A unique ID that remains the same throughout the microservices for particular request - same across the microservices 
c) Span ID - A unique ID per microservice 
d) Export Flag


================================
Steps to work with Zipkin Server
================================
1. Download Zipkin Jar file
   URL: https://zipkin.io/pages/quickstart.html

2. Run Zipkin jar file
   $ java -jar <jar-name>
zipkin-server-3.5.1-exec.jar

3. The default port of Zipkin server is 9411

4. Access Zipkin Server dashboard
    http://localhost:9411

Get Zipkin as a Docker image
$ docker run -d -p 9411:9411 openzipkin/zipkin

Get Zipkin from maven repository
browser> https://repo1.maven.org/maven2/io/zipkin/zipkin-server/3.5.1/
zipkin-server-3.5.1-exec.jar  

cmd> java -jar zipkin-server-3.5.1-exec.jar

Regardless of how you start Zipkin, browse to http://your_host:9411 to find traces


=============================================================
Convert our microservices as clients to Amin Server, Zipkin Server and Eureka Server
=============================================================
1. Add the following additional dependencies to all the 3 microservices - accounts, loans, cards
 - zipkin, admin-client along with eureka-discovery-client, spring web, devtools, actuator
-- our application act as a client to admin server, zipkin etc

2. in application.properties 
spring.boot.admin.client.url=http://localhost:1111


By using Admin Server we can monitor and manage our application - http://localhost:1111
 

In Spring Boot 3 and later, sensitive values in the /env and /configprops endpoints are hidden by default. 
To display these values, add the following configuration 
management.endpoint.env.show-values=ALWAYS
management.endpoint.configprops.show-values=ALWAYS



Question: How can you change the log level without restarting the application?  
Ans: Using Admin Server


===> Admin Dashboard displays the application details like beans, loggers, heap dump, thread dump, metrics, mappings etc

===> Zipkin Server Dashboard will display trace-id details




===============
Load Balancing
===============
Slide - 10

-> If we run our microservice/ application in one server then burden will be increased on that server
  
  1) Single server should handle all the load
  2) Burden on Server
  3) Response delay
  4) Server may crash
  5) Single point of failure

-> To overcome above problems - we should run our application in multiple servers - so that we can distribute the requests to multiple servers.

-> Load Balancer is used to distribute requests to multiple servers. 
Following are the advantages

  1) Less burden on server
  2) quick response to clients
  3) no single point of failure



PRACTICALS:
1. create a new micro service : welcome-service
dependencies: Spring Web, DevTools, Actuator, Admin Client, Zipkin, Eureka Discovery Client


--- application.properties ---  no port number is provided
spring.application.name=welcome-service
spring.boot.admin.client.url=http://localhost:1111
management.endpoints.web.exposure.include= *

-- WelcomeRestController.java ---

package com.cognizant.app.controllers;
@RestController
public class WelcomeRestController {
	@Autowired
	private Environment env;
	
	@GetMapping("/welcome")
	public String sendWelcomeMessage() {
		String port = env.getProperty("server.port");   // to send the port number as response
		return "Welcome to Cognizant..!! @ (" +  port + ")";
	}
}


-- start eureka server, admin-server

-- running 3 instances
Run As> Run Configurations - welcome-service > Arguments (tab) VM Arguments
-Dserver.port=8081

 

2. create a new micro service : greet-service
dependencies: Spring Web, DevTools, Actuator, Admin Client, Zipkin, Eureka Discovery Client, Open Feign

--- application.properties ---
spring.application.name=greet-service
spring.boot.admin.client.url=http://localhost:1111
management.endpoints.web.exposure.include= *
server.port=9091

-- on Bootstrap class - @EnableFeignClients

--- WelcomeFeignClient.java ---
@FeignClient("welcome-service")
public interface WelcomeFeignClient {
	@GetMapping("/welcome")
	public String sendWelcomeMessage();
}

--- GreetRestController.java ---
@RestController
public class GreetRestController {

	@Autowired
	private WelcomeFeignClient welcomeClient;

	@GetMapping("/greet")
	public String getGreetMsg() {

		String welcomeMsg = welcomeClient.sendWelcomeMessage();

		String greetMsg = "Greetings    ";

		return greetMsg + welcomeMsg;
	}

}


Ribbon is providing the load-balancing mechanism for the FeignClients.
Ribbon will distribute the load to multiple instances


Ribbon was historically a client-side load balancing library that was integrated with Feign clients, especially within the Spring Cloud ecosystem. While Feign handles the declarative HTTP client creation, it relies on a load balancer like Ribbon to distribute requests across multiple instances of a service. However, in recent versions of Spring Cloud, Ribbon has been replaced by the more modern Spring Cloud Load Balancer. 

Round Robin, Sticky Session or IP Hashing algorithms can also work to identify the instance

Server Side Load Balancer - AWS - AWS Elastic Load Balancing (ELB)



========================================
Working with Spring Cloud API Gateway
========================================

1) Create Spring boot application with below dependencies - api-gateway

		-> eureka-client
		-> cloud-reactive-gateway
		-> devtools

2) Configure API Gateway Routings in application.yml file like below

spring:
  application:
    name: api-gateway
  cloud:
    gateway:
      routes:
      - id: api-1
        uri: lb://WELCOME-SERVICE
        predicates: 
          - Path=/welcome
      - id: api-2
        uri: lb://GREET-SERVICE
        predicates: 
          - Path=/greet
server:
  port: 3333

3) Create Filter to validate incoming request

		if request contains below header then it is valid request so process it.

			Secret=sunil@123

		if above header is not present then it is invalid request, don't process it.					


@Component
public class MyFilter implements GlobalFilter {

	@Override
	public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {

		System.out.println(" filter() - executed..... ");

		// validate request
		
		ServerHttpRequest request = exchange.getRequest();
		HttpHeaders headers = request.getHeaders();
		Set<String> keySet = headers.keySet();
		
		if(!keySet.contains("Secret")) {
			throw new RuntimeException("Invalid Request");
		}
		
		List<String> list = headers.get("Secret");
		if(!list.get(0).equals("sunil@123")) {
			throw new RuntimeException("Invalid Request");
		}
		
		return chain.filter(exchange);
	}
}


================================
What is Cloud Config Server
================================

=> We are configuring our application config properties in application.properties or application.yml file.

	Ex: DB Props, SMTP props, Kafka Props, App Messages etc...

=> application.properties or application.yml file will be packaged along with our application (it will be part of our app jar file).

=> If we want to make any changes to properties then we have to re-package our application and we have to re-deploy our application.

Note: If any changes required in config properties then We have to repeat the complete project build & deployment which is time consuming process.

=> To avoid this problem, we have to seperate our project source code and project config properties files.

=> To externalize config properties from the application we can use Spring Cloud Config Server.


=> Cloud Config Server is part of Spring Cloud Library.


Note: Application config properties files we will maintain in git hub repo and config server will load them and will give to our application based on our application-name.

	
			App-name : flights ====> flights.yml

			App-name : hotels ====> hotels.yml

			App-name : trains ====> trains.yml

=> Our microservices will get config properties from Config server and config server will load them from git hub repo.


================================
Developing Config Server App
================================

1) Create Git Repository and keep ymls files required for microservices

			Note: We should keep file name as application name

			app name : greet  then file name : greet.yml

			app name : welcome then file name : welcome.yml


### Git Repo : https://github.com/suniljo/configuration_properties

2) Create Spring Starter application with below dependencies - config-server

		a) Config Server
		b) devtools

3) Write @EnableConfigServer annotation at boot start class

4) Configure below properties in application.yml file

spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: https://github.com/suniljo/configuration_properties
server:
  port: 9093	

5) Run Config Server application

=================================
Config Client Development
=================================

1) Create Spring Boot application with below dependencies

				a) web-starter
				b) config-client
				c) dev-tools
				d) actuators

2) Create Rest Controller with Required methods

@RestController
public class MsgRestController {

	@Value("${msg}")
	private String msg;

	@GetMapping("/")
	public String getMsg() {
		return msg;
	}

}				

3) Configure ConfigServer url in application.yml file like below

spring:
  application:
    name: welcome
  config:
    import: optional:configserver:http://localhost:9093


4) Run the application and test it.

==============================================
How to reload config properties dynamically 
==============================================

=> We need to make below 3 changes to reload latest config props

-> configure @RefreshScope annotation at Rest controller class

-> Enable actuator endpoint 'refresh' in application.yml
management.endpoints.web.exposure.include=refresh

-> Send post request to actuator endpoint 'refresh' from postman

-> After refresh, test your config client application